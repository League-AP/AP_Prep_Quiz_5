(function() {    var questions = [{
question: "Consider the following instance variable, arr, and incomplete method, partialSum. The method is intended to return an integer array sum such that for all k, sum[k] is equal to arr[0] + arr[1] + ... + arr[k]. For instance,if arr contains the values { 1, 4, 1, 3 }, the array sum will contain the values { 1, 5, 6, 9 }. <br>private int[] arr;<br>public int[] partialSum() { <br>&nbsp;&nbsp;&nbsp;&nbsp;int[] sum = new int[arr.length];<br>&nbsp;&nbsp;&nbsp;&nbsp;for (int j = 0; j < sum.length; j++) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum[j] = 0; <br>&nbsp;&nbsp;&nbsp;&nbsp;} <br>&nbsp;&nbsp;&nbsp;&nbsp;/* missing code */ <br>&nbsp;&nbsp;&nbsp;&nbsp;return sum; <br>} <br>The following two implementations /* missing code */ are proposed so that partialSum will work as intended. <br>Implementation 1  <br>&nbsp;&nbsp;&nbsp;&nbsp;for (int j = 0; j < arr.length; j++) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum[j] = sum[j - 1] + arr[j]; <br>&nbsp;&nbsp;&nbsp;&nbsp;} <br>Implementation 2 <br>&nbsp;&nbsp;&nbsp;&nbsp;for (int j = 0; j < arr.length; j++) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int k = 0; k <= j; k++) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum[j] = sum[j] + arr[k]; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br>&nbsp;&nbsp;&nbsp;&nbsp;} <br>Which of the following statements is true? ",
choices: ["Both implementations work as intended, but implementation 1 is faster than implementation 2. ", "Both implementations work as intended, but implementation 2 is faster than implementation 1.", "Both implementations work as intended and are equally fast. ", "Implementation 1 does not work as intended, because it will cause an ArrayIndexOutOfBoundsException.", "Implementation 2 does not work as intended, because it will cause an ArrayIndexOutOfBoundsException. "],
correctAnswer: 3
}, {
question: "Consider the following declaration for a class that will be used to represent points in the xy-coordinate plane. <br>public class Point <br>{ <br>&nbsp;&nbsp;&nbsp;&nbsp;private int x; // x-coordinate of the point <br>&nbsp;&nbsp;&nbsp;&nbsp;private int y; // y-coordinate of the point <br>&nbsp;&nbsp;&nbsp;&nbsp;public Point() <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = 0; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = 0; <br>&nbsp;&nbsp;&nbsp;&nbsp;} <br>&nbsp;&nbsp;&nbsp;&nbsp;public Point(int a, int b) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = a; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = b; &nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;} <br>&nbsp;&nbsp;&nbsp;&nbsp;// Other methods not shown <br>}<br>The following incomplete class declaration is intended to extend the above class so that points can be named. <br>public class NamedPoint extends Point <br>{ <br>&nbsp;&nbsp;&nbsp;&nbsp;private String name;  //name of point<br>&nbsp;&nbsp;&nbsp;&nbsp;// Constructors go here<br>&nbsp;&nbsp;&nbsp;&nbsp;//Other methods not shown<br>}<br>Consider the following proposed constructors for this class. <br>I.<br>public NamedPoint()<br>{ <br>&nbsp;&nbsp;&nbsp;&nbsp;name = ''''; <br>} <br>II.<br>public NamedPoint(int d1, int d2, String pointName)<br>{ <br>&nbsp;&nbsp;&nbsp;&nbsp;x = d1;<br>&nbsp;&nbsp;&nbsp;&nbsp;y = d2;<br>&nbsp;&nbsp;&nbsp;&nbsp;name = pointName; <br>} <br>III.<br>public NamedPoint(int d1, int d2, String pointName)<br>{ <br>&nbsp;&nbsp;&nbsp;&nbsp;super(d1, d2); <br>&nbsp;&nbsp;&nbsp;&nbsp;name = pointName; <br>} <br>Which of these constructors would be legal for the NamedPoint class? ",
choices: ["I only ", "II only ", "III only ", "I and III only ", "II and III only "],
correctAnswer: 3
}, {
question: "Consider a shuffle method that is intended to return a new array that contains all the elements from nums, but in a different order. Let n be the number of elements in nums. The shuffle method should alternate the elements from nums[0] ... nums[n / 2 – 1] with the elements from nums[n / 2] ... nums[n – 1], as illustrated in the following examples. <br>Example 1 <br>nums = {10, 20, 30, 40, 50, 60, 70, 80}<br>result = {10, 50, 20, 60, 30, 70, 40, 80}<br>Example 2 <br>nums = {10, 20, 30, 40, 50, 60, 70}<br>result = {10, 40, 20, 50, 30, 60, 70} <br><br>The following implementation of the shuffle method does not work as intended. <br>public static int[] shuffle(int[] nums) <br>{ <br>&nbsp;&nbsp;&nbsp;&nbsp;int n = nums.length;<br>&nbsp;&nbsp;&nbsp;&nbsp;int[] result = new int[n]; <br>&nbsp;&nbsp;&nbsp;&nbsp;for (int j = 0; j < n / 2; j++) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[j * 2] = nums[j]; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[j * 2 + 1] = nums[j + n / 2]; <br>&nbsp;&nbsp;&nbsp;&nbsp;} <br>&nbsp;&nbsp;&nbsp;&nbsp;return result; <br>} <br>Which of the following best describes the problem with the given implementation of the shuffle method?",
choices: ["Executing shuffle may cause an ArrayIndexOutOfBoundsException.", "The first element of the returned array (result[0]) may not have the correct value. ", "The last element of the returned array (result[result.length − 1]) may not have the correct value. ", "One or more of nums[0] ... nums[nums.length / 2 − 1] may have been copied to the wrong position(s) in the returned array. ", "One or more of nums[nums.length / 2] ... nums[nums.length − 1] may have been copied to the wrong position(s) in the returned array."],
correctAnswer: 2
}, {
question: "Consider the following Util class, which contains two methods. The completed sum1D method returns the sum of all the elements of the 1-dimensional array a. The incomplete sum2D method is intended to return the sum of all the elements of the 2-dimensional array m. <br>public class Util <br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;/** Returns the sum of the elements of the 1-dimensional array a */ <br>&nbsp;&nbsp;&nbsp;&nbsp;public static int sum1D(int[] a)<br>&nbsp;&nbsp;&nbsp;&nbsp;{ /* implementation not shown */ } <br>&nbsp;&nbsp;&nbsp;&nbsp;/** Returns the sum of the elements of the 2-dimensional array m */ <br>&nbsp;&nbsp;&nbsp;&nbsp;public static int sum2D(int[][] m)<br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int sum = 0; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* missing code */ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return sum; <br>&nbsp;&nbsp;&nbsp;&nbsp;} <br>}<br>Assume that sum1D works correctly. Which of the following can replace /* missing code */ so that the sum2D method works correctly? <br>I.<br>for (int k = 0; k < m.length; k++) <br>{ <br>&nbsp;&nbsp;&nbsp;&nbsp;sum += sum1D(m[k]); <br>} <br>II.<br>for (int[] row : m) <br>{ <br>&nbsp;&nbsp;&nbsp;&nbsp;sum += sum1D(row); <br>} <br>III.<br>for (int[] row : m) <br>{ <br>&nbsp;&nbsp;&nbsp;&nbsp;for (int v : row) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum += v; <br>&nbsp;&nbsp;&nbsp;&nbsp;} <br>} ",
choices: ["I only ", "II only ", "I and II only ", "II and III only ", "I, II, and III"],
correctAnswer: 4
}, {
question: "The following sort method correctly sorts the integers in elements into ascending order. <br>Line 1: &nbsp;&nbsp;&nbsp;&nbsp;public static void sort(int[] elements) <br>Line 2: &nbsp;&nbsp;&nbsp;&nbsp;{ <br>Line 3: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int j = 0; j < elements.length - 1; j++) <br>Line 4: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br>Line 5: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int index = j; <br>Line 6: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>Line 7:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int k = j + 1; k < elements.length; k++) <br>Line 8: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br>Line 9: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (elements[k] < elements[index]) <br>Line 10: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br>Line 11: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index = k; <br>Line 12: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br>Line 13: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br>Line 14: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>Line 15:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int temp = elements[j]; <br>Line 16: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements[j] = elements[index]; <br>Line 17: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements[index] = temp; <br>Line 18: &nbsp;&nbsp;&nbsp;&nbsp;} <br>Line 19:&nbsp;&nbsp;&nbsp;&nbsp;  } <br>Which of the following changes to the sort method would correctly sort the integers in elements into descending order? <br>I.<br>Replace line 9 with:<br>Line 9:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(elements[k] > elements[index])<br><br>II.<br>Replace lines 15-17 with:<br>Line 15:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int temp = elements[index]; <br>Line 16:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements[index] = elements[j]; <br>Line 17:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements[j] = temp; <br><br>III.<br>Replace line 3 with:<br>Line 3: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int j = elements.length − 1; j > 0; j−−) <br>and replace line 7 with:<br>Line 7:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int k = 0; k < j; k++)",
choices: ["I only ", "II only ", "I and II only ", "I and III only ", "I, II, and III"],
correctAnswer: 3
}];
    var questionCounter = 0;   var selections = [];  var quiz = $('#quiz');    displayNext();    $('#next').on('click', function (e) {    e.preventDefault();        if(quiz.is(':animated')) {              return false;    }    choose();        if (isNaN(selections[questionCounter])) {      alert('Please make a selection!');    } else {      questionCounter++;      displayNext();    }  });    $('#prev').on('click', function (e) {    e.preventDefault();        if(quiz.is(':animated')) {      return false;    }    choose();    questionCounter--;    displayNext();  });    $('#start').on('click', function (e) {    e.preventDefault();        if(quiz.is(':animated')) {      return false;    }    questionCounter = 0;    selections = [];    displayNext();    $('#start').hide();  });    $('.button').on('mouseenter', function () {    $(this).addClass('active');  });  $('.button').on('mouseleave', function () {    $(this).removeClass('active');  });    function createQuestionElement(index) {    var qElement = $('<div>', {      id: 'question'    });        var header = $('<h2>Question ' + (index + 1) + ':</h2>');    qElement.append(header);        var question = $('<p>').append(questions[index].question);    qElement.append(question);        var radioButtons = createRadios(index);    qElement.append(radioButtons);        return qElement;  }    function createRadios(index) {    var radioList = $('<ul>');    var item;    var input = '';    for (var i = 0; i < questions[index].choices.length; i++) {      item = $('<li>');      input = '<input type="radio" name="answer" value=' + i + ' />';	  input += convertToLetter(i) + ':<br>';      input += questions[index].choices[i];      input += '<hr size=2>';      item.append(input);      radioList.append(item);    }    return radioList;  }  function choose() {    selections[questionCounter] = +$('input[name="answer"]:checked').val();  }    function displayNext() {    quiz.fadeOut(function() {      $('#question').remove();            if(questionCounter < questions.length){        var nextQuestion = createQuestionElement(questionCounter);        quiz.append(nextQuestion).fadeIn();        if (!(isNaN(selections[questionCounter]))) {          $('input[value='+selections[questionCounter]+']').prop('checked', true);        }                if(questionCounter === 1){          $('#prev').show();        } else if(questionCounter === 0){                    $('#prev').hide();          $('#next').show();        }      }else {        var scoreElem = displayScore();        quiz.append(scoreElem).fadeIn();        $('#next').hide();        $('#prev').hide();        $('#start').show();      }    });  }  function displayScore() {    var score = $('<p>',{id: 'question'});    var numCorrect = 0;    for (var i = 0; i < selections.length; i++) {      if (selections[i] === questions[i].correctAnswer) {        numCorrect++;      }    }	score.append('<br>You got ' + numCorrect + ' questions out of ' + questions.length + ' correct.<hr size=2>');    	for(var i = 0; i < questions.length; i++){				score.append('<br> Question: ' + (i + 1) + '<br>');		score.append('<br>' + questions[i].question + '<br>');				for(var j = 0; j < questions[i].choices.length; j++){			score.append(convertToLetter(j) + ":<br>" + questions[i].choices[j] + '<br>');		}				score.append('<br> Your Answer: ' + convertToLetter(selections[i]) + '<br>');		score.append('<br> Correct Answer: ' + convertToLetter(questions[i].correctAnswer) + "<hr size=2>");	}    return score;  }})();function convertToLetter(i){		var letter;		switch(i){			case 0: letter = 'A';					break; 			case 1: letter = 'B';					break;			case 2: letter = 'C';					break;			case 3: letter = 'D';					break;			case 4: letter = 'E';					break;		}		return letter;	}